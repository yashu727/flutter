/ lib/main.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'firebase_options.dart'; // generated by flutterfire configure

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const CakeApp());
}

/// Simple Cake Ordering App (single-file).
/// - Email/password auth
/// - Users can place cake orders
/// - Admin can view all orders and update status
///
/// Note: Set isAdminEmail to the admin account email (or implement a proper role system).
const String isAdminEmail = 'admin@cakeapp.com';

class CakeApp extends StatelessWidget {
  const CakeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Cake Shop',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(primarySwatch: Colors.pink),
      home: const RootPage(),
    );
  }
}

/// Root switches between Auth and Main app based on auth state
class RootPage extends StatelessWidget {
  const RootPage({super.key});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snap) {
        if (snap.connectionState == ConnectionState.waiting) {
          return const Scaffold(body: Center(child: CircularProgressIndicator()));
        }
        final user = snap.data;
        if (user == null) return const AuthPage();
        return HomePage(user: user);
      },
    );
  }
}

/// -----------------
/// Authentication Page
/// -----------------
class AuthPage extends StatefulWidget {
  const AuthPage({super.key});

  @override
  State<AuthPage> createState() => _AuthPageState();
}

class _AuthPageState extends State<AuthPage> {
  final _emailC = TextEditingController();
  final _passC = TextEditingController();
  bool _isLogin = true;
  bool _loading = false;

  Future<void> _submit() async {
    if (_emailC.text.trim().isEmpty || _passC.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Enter email and password')));
      return;
    }
    setState(() => _loading = true);
    try {
      final email = _emailC.text.trim();
      final pass = _passC.text.trim();
      if (_isLogin) {
        await FirebaseAuth.instance.signInWithEmailAndPassword(email: email, password: pass);
      } else {
        await FirebaseAuth.instance.createUserWithEmailAndPassword(email: email, password: pass);
      }
    } on FirebaseAuthException catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.message ?? 'Auth error')));
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  void dispose() {
    _emailC.dispose();
    _passC.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Cake Shop — Sign In')),
      body: Center(
        child: Card(
          margin: const EdgeInsets.symmetric(horizontal: 20),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 420),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(_isLogin ? 'Welcome back' : 'Create an account', style: Theme.of(context).textTheme.headline6),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _emailC,
                    keyboardType: TextInputType.emailAddress,
                    decoration: const InputDecoration(labelText: 'Email'),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: _passC,
                    obscureText: true,
                    decoration: const InputDecoration(labelText: 'Password'),
                  ),
                  const SizedBox(height: 16),
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton(
                      onPressed: _loading ? null : _submit,
                      child: _loading ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)) : Text(_isLogin ? 'Login' : 'Register'),
                    ),
                  ),
                  TextButton(
                    onPressed: () => setState(() => _isLogin = !_isLogin),
                    child: Text(_isLogin ? 'Create new account' : 'Have an account? Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// -----------------
/// Home Page: shows user order UI or admin panel based on email
/// -----------------
class HomePage extends StatelessWidget {
  final User user;
  const HomePage({required this.user, super.key});

  bool get isAdmin => user.email?.toLowerCase() == isAdminEmail.toLowerCase();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(isAdmin ? 'Admin Panel' : 'Cake Shop'),
        actions: [
          IconButton(
            onPressed: () => FirebaseAuth.instance.signOut(),
            icon: const Icon(Icons.logout),
            tooltip: 'Logout',
          ),
        ],
      ),
      body: isAdmin ? AdminPanel(user: user) : OrderScreen(user: user),
    );
  }
}

/// -----------------
/// Ordering UI for regular users
/// -----------------
class OrderScreen extends StatefulWidget {
  final User user;
  const OrderScreen({required this.user, super.key});

  @override
  State<OrderScreen> createState() => _OrderScreenState();
}

class _OrderScreenState extends State<OrderScreen> {
  final _formKey = GlobalKey<FormState>();
  String _selectedCake = 'Chocolate Fudge';
  String _selectedSize = 'Small';
  int _quantity = 1;
  final _notesC = TextEditingController();

  final List<String> cakes = [
    'Chocolate Fudge',
    'Vanilla Berry',
    'Red Velvet',
    'Black Forest',
    'Cheesecake'
  ];

  final List<String> sizes = ['Small', 'Medium', 'Large'];

  bool _saving = false;

  Future<void> _placeOrder() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() => _saving = true);
    try {
      final orders = FirebaseFirestore.instance.collection('orders');
      await orders.add({
        'cake': _selectedCake,
        'size': _selectedSize,
        'quantity': _quantity,
        'notes': _notesC.text.trim(),
        'status': 'Pending',
        'userId': widget.user.uid,
        'userEmail': widget.user.email,
        'createdAt': FieldValue.serverTimestamp(),
      });
      // Clear (but keep selections)
      _notesC.clear();
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Order placed!')));
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e')));
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }

  @override
  void dispose() {
    _notesC.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Simple UI with cake preview images (network placeholders)
    return SingleChildScrollView(
      padding: const EdgeInsets.all(12),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 700),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 6),
            const Text('Place your cake order', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 12),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(12.0),
                child: Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      DropdownButtonFormField<String>(
                        value: _selectedCake,
                        items: cakes.map((c) => DropdownMenuItem(value: c, child: Text(c))).toList(),
                        onChanged: (v) => setState(() => _selectedCake = v!),
                        decoration: const InputDecoration(labelText: 'Cake type'),
                      ),
                      const SizedBox(height: 8),
                      DropdownButtonFormField<String>(
                        value: _selectedSize,
                        items: sizes.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
                        onChanged: (v) => setState(() => _selectedSize = v!),
                        decoration: const InputDecoration(labelText: 'Size'),
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          const Text('Quantity:'),
                          const SizedBox(width: 12),
                          IconButton(
                            icon: const Icon(Icons.remove),
                            onPressed: _quantity > 1 ? () => setState(() => _quantity--) : null,
                          ),
                          Text('$_quantity'),
                          IconButton(icon: const Icon(Icons.add), onPressed: () => setState(() => _quantity++)),
                          const Spacer(),
                          ElevatedButton.icon(
                            onPressed: _saving ? null : _placeOrder,
                            icon: _saving ? const SizedBox(width: 14, height: 14, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)) : const Icon(Icons.shopping_cart),
                            label: Text(_saving ? 'Placing...' : 'Place Order'),
                          )
                        ],
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _notesC,
                        decoration: const InputDecoration(labelText: 'Notes (e.g., message on cake, delivery time)'),
                        maxLines: 3,
                      ),
                    ],
                  ),
                ),
              ),
            ),
            const SizedBox(height: 12),
            const Text('Cake Preview', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            // Simple grid of sample images with labels
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: cakes.map((c) => CakePreviewCard(title: c, selected: c == _selectedCake, onTap: () => setState(() => _selectedCake = c))).toList(),
            ),
            const SizedBox(height: 18),
            const Text('Your Orders', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            // Show this user's orders
            StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
              stream: FirebaseFirestore.instance
                  .collection('orders')
                  .where('userId', isEqualTo: widget.user.uid)
                  .orderBy('createdAt', descending: true)
                  .snapshots(),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) return const Center(child: CircularProgressIndicator());
                final docs = snap.data?.docs ?? [];
                if (docs.isEmpty) return const Text('No orders yet.');
                return ListView.separated(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: docs.length,
                  separatorBuilder: (, _) => const SizedBox(height: 8),
                  itemBuilder: (context, i) {
                    final d = docs[i];
                    final data = d.data();
                    return OrderTile(
                      orderId: d.id,
                      cake: data['cake'] ?? '',
                      size: data['size'] ?? '',
                      qty: data['quantity'] ?? 1,
                      notes: data['notes'] ?? '',
                      status: data['status'] ?? 'Pending',
                      isAdminView: false,
                    );
                  },
                );
              },
            ),
            const SizedBox(height: 40),
          ],
        ),
      ),
    );
  }
}

/// A small card showing cake image and name
class CakePreviewCard extends StatelessWidget {
  final String title;
  final bool selected;
  final VoidCallback onTap;
  const CakePreviewCard({required this.title, required this.selected, required this.onTap, super.key});

  // simple mapping to images (public placeholder images)
  String get imageUrl {
    if (title.toLowerCase().contains('chocolate')) return 'https://images.unsplash.com/photo-1604908177522-1a2c88f4d2c7?auto=format&fit=crop&w=800&q=60';
    if (title.toLowerCase().contains('vanilla')) return 'https://images.unsplash.com/photo-1542838132-92c53300491e?auto=format&fit=crop&w=800&q=60';
    if (title.toLowerCase().contains('red velvet')) return 'https://images.unsplash.com/photo-1562440499-64f539d6d6b0?auto=format&fit=crop&w=800&q=60';
    if (title.toLowerCase().contains('black forest')) return 'https://images.unsplash.com/photo-1543779509-ec1ff8a0a6b8?auto=format&fit=crop&w=800&q=60';
    return 'https://images.unsplash.com/photo-1543349684-3f08a8f9a6b3?auto=format&fit=crop&w=800&q=60';
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 160,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: selected ? Colors.pink : Colors.grey.shade300, width: selected ? 2 : 1),
          color: Colors.white,
          boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.04), blurRadius: 6)],
        ),
        child: Column(
          children: [
            ClipRRect(borderRadius: const BorderRadius.vertical(top: Radius.circular(12)), child: Image.network(imageUrl, height: 100, width: 160, fit: BoxFit.cover)),
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: Text(title, textAlign: TextAlign.center, style: const TextStyle(fontWeight: FontWeight.w600)),
            ),
          ],
        ),
      ),
    );
  }
}

/// -----------------
/// Admin Panel (see all orders)
/// -----------------
class AdminPanel extends StatelessWidget {
  final User user;
  const AdminPanel({required this.user, super.key});

  @override
  Widget build(BuildContext context) {
    // stream all orders
    return Padding(
      padding: const EdgeInsets.all(12.0),
      child: Column(
        children: [
          Text('Signed in as ${user.email}', style: const TextStyle(fontSize: 14)),
          const SizedBox(height: 12),
          Expanded(
            child: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
              stream: FirebaseFirestore.instance.collection('orders').orderBy('createdAt', descending: true).snapshots(),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) return const Center(child: CircularProgressIndicator());
                final docs = snap.data?.docs ?? [];
                if (docs.isEmpty) return const Center(child: Text('No orders yet.'));
                return ListView.separated(
                  itemCount: docs.length,
                  separatorBuilder: (, _) => const Divider(),
                  itemBuilder: (context, i) {
                    final d = docs[i];
                    final data = d.data();
                    return OrderTile(
                      orderId: d.id,
                      cake: data['cake'] ?? '',
                      size: data['size'] ?? '',
                      qty: data['quantity'] ?? 1,
                      notes: data['notes'] ?? '',
                      status: data['status'] ?? 'Pending',
                      userEmail: data['userEmail'] ?? '',
                      isAdminView: true,
                    );
                  },
                );
              },
            ),
          )
        ],
      ),
    );
  }
}

/// Reusable widget that shows an order and (if admin) allows status update
class OrderTile extends StatelessWidget {
  final String orderId;
  final String cake;
  final String size;
  final int qty;
  final String notes;
  final String status;
  final String? userEmail;
  final bool isAdminView;

  const OrderTile({
    required this.orderId,
    required this.cake,
    required this.size,
    required this.qty,
    required this.notes,
    required this.status,
    this.userEmail,
    required this.isAdminView,
    super.key,
  });

  static const List<String> statuses = ['Pending', 'Preparing', 'Ready', 'Delivered', 'Cancelled'];

  Future<void> _updateStatus(BuildContext context, String newStatus) async {
    try {
      await FirebaseFirestore.instance.collection('orders').doc(orderId).update({'status': newStatus});
      if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Status updated to $newStatus')));
    } catch (e) {
      if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Update failed: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    final idx = statuses.indexOf(status);
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Row(children: [
            Expanded(child: Text(cake, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))),
            Chip(label: Text(status, style: const TextStyle(color: Colors.white)), backgroundColor: _statusColor(status)),
          ]),
          const SizedBox(height: 8),
          Text('Size: $size • Qty: $qty' + (userEmail != null ? ' • by $userEmail' : '')),
          if (notes.isNotEmpty) ...[
            const SizedBox(height: 8),
            Text('Notes: $notes'),
          ],
          const SizedBox(height: 10),
          if (isAdminView)
            Row(
              children: [
                const Text('Change status:'),
                const SizedBox(width: 8),
                DropdownButton<String>(
                  value: status,
                  items: statuses.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
                  onChanged: (v) {
                    if (v != null && v != status) _updateStatus(context, v);
                  },
                ),
                const Spacer(),
                IconButton(
                  onPressed: () => _showDeleteConfirm(context),
                  icon: const Icon(Icons.delete, color: Colors.red),
                  tooltip: 'Delete order',
                ),
              ],
            ),
        ]),
      ),
    );
  }

  Color _statusColor(String s) {
    switch (s) {
      case 'Pending':
        return Colors.orange;
      case 'Preparing':
        return Colors.purple;
      case 'Ready':
        return Colors.blue;
      case 'Delivered':
        return Colors.green;
      case 'Cancelled':
        return Colors.grey;
      default:
        return Colors.black;
    }
  }

  void _showDeleteConfirm(BuildContext context) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete order?'),
        content: const Text('This will remove the order permanently.'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancel')),
          ElevatedButton(
            onPressed: () async {
              Navigator.of(ctx).pop();
              await FirebaseFirestore.instance.collection('orders').doc(orderId).delete();
              if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Order deleted')));
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
}